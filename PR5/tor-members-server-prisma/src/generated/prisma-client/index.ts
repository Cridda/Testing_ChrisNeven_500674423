// Code generated by Prisma (prisma@1.22.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  accommodation: (where?: AccommodationWhereInput) => Promise<boolean>;
  accommodationFeature: (
    where?: AccommodationFeatureWhereInput
  ) => Promise<boolean>;
  accommodationType: (where?: AccommodationTypeWhereInput) => Promise<boolean>;
  address: (where?: AddressWhereInput) => Promise<boolean>;
  bathroom: (where?: BathroomWhereInput) => Promise<boolean>;
  bathroomType: (where?: BathroomTypeWhereInput) => Promise<boolean>;
  bedroom: (where?: BedroomWhereInput) => Promise<boolean>;
  bedroomType: (where?: BedroomTypeWhereInput) => Promise<boolean>;
  city: (where?: CityWhereInput) => Promise<boolean>;
  photo: (where?: PhotoWhereInput) => Promise<boolean>;
  site: (where?: SiteWhereInput) => Promise<boolean>;
  translatableString: (
    where?: TranslatableStringWhereInput
  ) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  accommodation: (where: AccommodationWhereUniqueInput) => AccommodationPromise;
  accommodations: (
    args?: {
      where?: AccommodationWhereInput;
      orderBy?: AccommodationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Accommodation>;
  accommodationsConnection: (
    args?: {
      where?: AccommodationWhereInput;
      orderBy?: AccommodationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AccommodationConnectionPromise;
  accommodationFeature: (
    where: AccommodationFeatureWhereUniqueInput
  ) => AccommodationFeaturePromise;
  accommodationFeatures: (
    args?: {
      where?: AccommodationFeatureWhereInput;
      orderBy?: AccommodationFeatureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AccommodationFeature>;
  accommodationFeaturesConnection: (
    args?: {
      where?: AccommodationFeatureWhereInput;
      orderBy?: AccommodationFeatureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AccommodationFeatureConnectionPromise;
  accommodationType: (
    where: AccommodationTypeWhereUniqueInput
  ) => AccommodationTypePromise;
  accommodationTypes: (
    args?: {
      where?: AccommodationTypeWhereInput;
      orderBy?: AccommodationTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AccommodationType>;
  accommodationTypesConnection: (
    args?: {
      where?: AccommodationTypeWhereInput;
      orderBy?: AccommodationTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AccommodationTypeConnectionPromise;
  address: (where: AddressWhereUniqueInput) => AddressPromise;
  addresses: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Address>;
  addressesConnection: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AddressConnectionPromise;
  bathroom: (where: BathroomWhereUniqueInput) => BathroomPromise;
  bathrooms: (
    args?: {
      where?: BathroomWhereInput;
      orderBy?: BathroomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Bathroom>;
  bathroomsConnection: (
    args?: {
      where?: BathroomWhereInput;
      orderBy?: BathroomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BathroomConnectionPromise;
  bathroomType: (where: BathroomTypeWhereUniqueInput) => BathroomTypePromise;
  bathroomTypes: (
    args?: {
      where?: BathroomTypeWhereInput;
      orderBy?: BathroomTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BathroomType>;
  bathroomTypesConnection: (
    args?: {
      where?: BathroomTypeWhereInput;
      orderBy?: BathroomTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BathroomTypeConnectionPromise;
  bedroom: (where: BedroomWhereUniqueInput) => BedroomPromise;
  bedrooms: (
    args?: {
      where?: BedroomWhereInput;
      orderBy?: BedroomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Bedroom>;
  bedroomsConnection: (
    args?: {
      where?: BedroomWhereInput;
      orderBy?: BedroomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BedroomConnectionPromise;
  bedroomType: (where: BedroomTypeWhereUniqueInput) => BedroomTypePromise;
  bedroomTypes: (
    args?: {
      where?: BedroomTypeWhereInput;
      orderBy?: BedroomTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BedroomType>;
  bedroomTypesConnection: (
    args?: {
      where?: BedroomTypeWhereInput;
      orderBy?: BedroomTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BedroomTypeConnectionPromise;
  city: (where: CityWhereUniqueInput) => CityPromise;
  cities: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<City>;
  citiesConnection: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CityConnectionPromise;
  photo: (where: PhotoWhereUniqueInput) => PhotoPromise;
  photos: (
    args?: {
      where?: PhotoWhereInput;
      orderBy?: PhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Photo>;
  photosConnection: (
    args?: {
      where?: PhotoWhereInput;
      orderBy?: PhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PhotoConnectionPromise;
  site: (where: SiteWhereUniqueInput) => SitePromise;
  sites: (
    args?: {
      where?: SiteWhereInput;
      orderBy?: SiteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Site>;
  sitesConnection: (
    args?: {
      where?: SiteWhereInput;
      orderBy?: SiteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SiteConnectionPromise;
  translatableString: (
    where: TranslatableStringWhereUniqueInput
  ) => TranslatableStringPromise;
  translatableStrings: (
    args?: {
      where?: TranslatableStringWhereInput;
      orderBy?: TranslatableStringOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TranslatableString>;
  translatableStringsConnection: (
    args?: {
      where?: TranslatableStringWhereInput;
      orderBy?: TranslatableStringOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TranslatableStringConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccommodation: (data: AccommodationCreateInput) => AccommodationPromise;
  updateAccommodation: (
    args: {
      data: AccommodationUpdateInput;
      where: AccommodationWhereUniqueInput;
    }
  ) => AccommodationPromise;
  updateManyAccommodations: (
    args: {
      data: AccommodationUpdateManyMutationInput;
      where?: AccommodationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAccommodation: (
    args: {
      where: AccommodationWhereUniqueInput;
      create: AccommodationCreateInput;
      update: AccommodationUpdateInput;
    }
  ) => AccommodationPromise;
  deleteAccommodation: (
    where: AccommodationWhereUniqueInput
  ) => AccommodationPromise;
  deleteManyAccommodations: (
    where?: AccommodationWhereInput
  ) => BatchPayloadPromise;
  createAccommodationFeature: (
    data: AccommodationFeatureCreateInput
  ) => AccommodationFeaturePromise;
  updateAccommodationFeature: (
    args: {
      data: AccommodationFeatureUpdateInput;
      where: AccommodationFeatureWhereUniqueInput;
    }
  ) => AccommodationFeaturePromise;
  updateManyAccommodationFeatures: (
    args: {
      data: AccommodationFeatureUpdateManyMutationInput;
      where?: AccommodationFeatureWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAccommodationFeature: (
    args: {
      where: AccommodationFeatureWhereUniqueInput;
      create: AccommodationFeatureCreateInput;
      update: AccommodationFeatureUpdateInput;
    }
  ) => AccommodationFeaturePromise;
  deleteAccommodationFeature: (
    where: AccommodationFeatureWhereUniqueInput
  ) => AccommodationFeaturePromise;
  deleteManyAccommodationFeatures: (
    where?: AccommodationFeatureWhereInput
  ) => BatchPayloadPromise;
  createAccommodationType: (
    data: AccommodationTypeCreateInput
  ) => AccommodationTypePromise;
  updateAccommodationType: (
    args: {
      data: AccommodationTypeUpdateInput;
      where: AccommodationTypeWhereUniqueInput;
    }
  ) => AccommodationTypePromise;
  updateManyAccommodationTypes: (
    args: {
      data: AccommodationTypeUpdateManyMutationInput;
      where?: AccommodationTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAccommodationType: (
    args: {
      where: AccommodationTypeWhereUniqueInput;
      create: AccommodationTypeCreateInput;
      update: AccommodationTypeUpdateInput;
    }
  ) => AccommodationTypePromise;
  deleteAccommodationType: (
    where: AccommodationTypeWhereUniqueInput
  ) => AccommodationTypePromise;
  deleteManyAccommodationTypes: (
    where?: AccommodationTypeWhereInput
  ) => BatchPayloadPromise;
  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (
    args: { data: AddressUpdateInput; where: AddressWhereUniqueInput }
  ) => AddressPromise;
  updateManyAddresses: (
    args: { data: AddressUpdateManyMutationInput; where?: AddressWhereInput }
  ) => BatchPayloadPromise;
  upsertAddress: (
    args: {
      where: AddressWhereUniqueInput;
      create: AddressCreateInput;
      update: AddressUpdateInput;
    }
  ) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createBathroom: (data: BathroomCreateInput) => BathroomPromise;
  updateBathroom: (
    args: { data: BathroomUpdateInput; where: BathroomWhereUniqueInput }
  ) => BathroomPromise;
  updateManyBathrooms: (
    args: { data: BathroomUpdateManyMutationInput; where?: BathroomWhereInput }
  ) => BatchPayloadPromise;
  upsertBathroom: (
    args: {
      where: BathroomWhereUniqueInput;
      create: BathroomCreateInput;
      update: BathroomUpdateInput;
    }
  ) => BathroomPromise;
  deleteBathroom: (where: BathroomWhereUniqueInput) => BathroomPromise;
  deleteManyBathrooms: (where?: BathroomWhereInput) => BatchPayloadPromise;
  createBathroomType: (data: BathroomTypeCreateInput) => BathroomTypePromise;
  updateBathroomType: (
    args: { data: BathroomTypeUpdateInput; where: BathroomTypeWhereUniqueInput }
  ) => BathroomTypePromise;
  updateManyBathroomTypes: (
    args: {
      data: BathroomTypeUpdateManyMutationInput;
      where?: BathroomTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBathroomType: (
    args: {
      where: BathroomTypeWhereUniqueInput;
      create: BathroomTypeCreateInput;
      update: BathroomTypeUpdateInput;
    }
  ) => BathroomTypePromise;
  deleteBathroomType: (
    where: BathroomTypeWhereUniqueInput
  ) => BathroomTypePromise;
  deleteManyBathroomTypes: (
    where?: BathroomTypeWhereInput
  ) => BatchPayloadPromise;
  createBedroom: (data: BedroomCreateInput) => BedroomPromise;
  updateBedroom: (
    args: { data: BedroomUpdateInput; where: BedroomWhereUniqueInput }
  ) => BedroomPromise;
  updateManyBedrooms: (
    args: { data: BedroomUpdateManyMutationInput; where?: BedroomWhereInput }
  ) => BatchPayloadPromise;
  upsertBedroom: (
    args: {
      where: BedroomWhereUniqueInput;
      create: BedroomCreateInput;
      update: BedroomUpdateInput;
    }
  ) => BedroomPromise;
  deleteBedroom: (where: BedroomWhereUniqueInput) => BedroomPromise;
  deleteManyBedrooms: (where?: BedroomWhereInput) => BatchPayloadPromise;
  createBedroomType: (data: BedroomTypeCreateInput) => BedroomTypePromise;
  updateBedroomType: (
    args: { data: BedroomTypeUpdateInput; where: BedroomTypeWhereUniqueInput }
  ) => BedroomTypePromise;
  updateManyBedroomTypes: (
    args: {
      data: BedroomTypeUpdateManyMutationInput;
      where?: BedroomTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBedroomType: (
    args: {
      where: BedroomTypeWhereUniqueInput;
      create: BedroomTypeCreateInput;
      update: BedroomTypeUpdateInput;
    }
  ) => BedroomTypePromise;
  deleteBedroomType: (where: BedroomTypeWhereUniqueInput) => BedroomTypePromise;
  deleteManyBedroomTypes: (
    where?: BedroomTypeWhereInput
  ) => BatchPayloadPromise;
  createCity: (data: CityCreateInput) => CityPromise;
  updateCity: (
    args: { data: CityUpdateInput; where: CityWhereUniqueInput }
  ) => CityPromise;
  updateManyCities: (
    args: { data: CityUpdateManyMutationInput; where?: CityWhereInput }
  ) => BatchPayloadPromise;
  upsertCity: (
    args: {
      where: CityWhereUniqueInput;
      create: CityCreateInput;
      update: CityUpdateInput;
    }
  ) => CityPromise;
  deleteCity: (where: CityWhereUniqueInput) => CityPromise;
  deleteManyCities: (where?: CityWhereInput) => BatchPayloadPromise;
  createPhoto: (data: PhotoCreateInput) => PhotoPromise;
  updatePhoto: (
    args: { data: PhotoUpdateInput; where: PhotoWhereUniqueInput }
  ) => PhotoPromise;
  updateManyPhotos: (
    args: { data: PhotoUpdateManyMutationInput; where?: PhotoWhereInput }
  ) => BatchPayloadPromise;
  upsertPhoto: (
    args: {
      where: PhotoWhereUniqueInput;
      create: PhotoCreateInput;
      update: PhotoUpdateInput;
    }
  ) => PhotoPromise;
  deletePhoto: (where: PhotoWhereUniqueInput) => PhotoPromise;
  deleteManyPhotos: (where?: PhotoWhereInput) => BatchPayloadPromise;
  createSite: (data: SiteCreateInput) => SitePromise;
  updateSite: (
    args: { data: SiteUpdateInput; where: SiteWhereUniqueInput }
  ) => SitePromise;
  updateManySites: (
    args: { data: SiteUpdateManyMutationInput; where?: SiteWhereInput }
  ) => BatchPayloadPromise;
  upsertSite: (
    args: {
      where: SiteWhereUniqueInput;
      create: SiteCreateInput;
      update: SiteUpdateInput;
    }
  ) => SitePromise;
  deleteSite: (where: SiteWhereUniqueInput) => SitePromise;
  deleteManySites: (where?: SiteWhereInput) => BatchPayloadPromise;
  createTranslatableString: (
    data: TranslatableStringCreateInput
  ) => TranslatableStringPromise;
  updateTranslatableString: (
    args: {
      data: TranslatableStringUpdateInput;
      where: TranslatableStringWhereUniqueInput;
    }
  ) => TranslatableStringPromise;
  updateManyTranslatableStrings: (
    args: {
      data: TranslatableStringUpdateManyMutationInput;
      where?: TranslatableStringWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTranslatableString: (
    args: {
      where: TranslatableStringWhereUniqueInput;
      create: TranslatableStringCreateInput;
      update: TranslatableStringUpdateInput;
    }
  ) => TranslatableStringPromise;
  deleteTranslatableString: (
    where: TranslatableStringWhereUniqueInput
  ) => TranslatableStringPromise;
  deleteManyTranslatableStrings: (
    where?: TranslatableStringWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accommodation: (
    where?: AccommodationSubscriptionWhereInput
  ) => AccommodationSubscriptionPayloadSubscription;
  accommodationFeature: (
    where?: AccommodationFeatureSubscriptionWhereInput
  ) => AccommodationFeatureSubscriptionPayloadSubscription;
  accommodationType: (
    where?: AccommodationTypeSubscriptionWhereInput
  ) => AccommodationTypeSubscriptionPayloadSubscription;
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  bathroom: (
    where?: BathroomSubscriptionWhereInput
  ) => BathroomSubscriptionPayloadSubscription;
  bathroomType: (
    where?: BathroomTypeSubscriptionWhereInput
  ) => BathroomTypeSubscriptionPayloadSubscription;
  bedroom: (
    where?: BedroomSubscriptionWhereInput
  ) => BedroomSubscriptionPayloadSubscription;
  bedroomType: (
    where?: BedroomTypeSubscriptionWhereInput
  ) => BedroomTypeSubscriptionPayloadSubscription;
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  photo: (
    where?: PhotoSubscriptionWhereInput
  ) => PhotoSubscriptionPayloadSubscription;
  site: (
    where?: SiteSubscriptionWhereInput
  ) => SiteSubscriptionPayloadSubscription;
  translatableString: (
    where?: TranslatableStringSubscriptionWhereInput
  ) => TranslatableStringSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PhotoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AccommodationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "livingArea_ASC"
  | "livingArea_DESC"
  | "outsideArea_ASC"
  | "outsideArea_DESC"
  | "contactPerson_ASC"
  | "contactPerson_DESC"
  | "contactPhone_ASC"
  | "contactPhone_DESC"
  | "minCapacity_ASC"
  | "minCapacity_DESC"
  | "maxCapacity_ASC"
  | "maxCapacity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BedroomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "singleBed_ASC"
  | "singleBed_DESC"
  | "doubleBed_ASC"
  | "doubleBed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BathroomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "toilet_ASC"
  | "toilet_DESC"
  | "bath_ASC"
  | "bath_DESC"
  | "shower_ASC"
  | "shower_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SiteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AccommodationFeatureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AccommodationTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "address_ASC"
  | "address_DESC"
  | "postcode_ASC"
  | "postcode_DESC"
  | "city_ASC"
  | "city_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BathroomTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BedroomTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TranslatableStringOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "en_ASC"
  | "en_DESC"
  | "nl_ASC"
  | "nl_DESC"
  | "de_ASC"
  | "de_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AccommodationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PhotoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  name?: TranslatableStringWhereInput;
  AND?: PhotoWhereInput[] | PhotoWhereInput;
  OR?: PhotoWhereInput[] | PhotoWhereInput;
  NOT?: PhotoWhereInput[] | PhotoWhereInput;
}

export interface TranslatableStringWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  en?: String;
  en_not?: String;
  en_in?: String[] | String;
  en_not_in?: String[] | String;
  en_lt?: String;
  en_lte?: String;
  en_gt?: String;
  en_gte?: String;
  en_contains?: String;
  en_not_contains?: String;
  en_starts_with?: String;
  en_not_starts_with?: String;
  en_ends_with?: String;
  en_not_ends_with?: String;
  nl?: String;
  nl_not?: String;
  nl_in?: String[] | String;
  nl_not_in?: String[] | String;
  nl_lt?: String;
  nl_lte?: String;
  nl_gt?: String;
  nl_gte?: String;
  nl_contains?: String;
  nl_not_contains?: String;
  nl_starts_with?: String;
  nl_not_starts_with?: String;
  nl_ends_with?: String;
  nl_not_ends_with?: String;
  de?: String;
  de_not?: String;
  de_in?: String[] | String;
  de_not_in?: String[] | String;
  de_lt?: String;
  de_lte?: String;
  de_gt?: String;
  de_gte?: String;
  de_contains?: String;
  de_not_contains?: String;
  de_starts_with?: String;
  de_not_starts_with?: String;
  de_ends_with?: String;
  de_not_ends_with?: String;
  AND?: TranslatableStringWhereInput[] | TranslatableStringWhereInput;
  OR?: TranslatableStringWhereInput[] | TranslatableStringWhereInput;
  NOT?: TranslatableStringWhereInput[] | TranslatableStringWhereInput;
}

export interface AccommodationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: Int;
  code_not?: Int;
  code_in?: Int[] | Int;
  code_not_in?: Int[] | Int;
  code_lt?: Int;
  code_lte?: Int;
  code_gt?: Int;
  code_gte?: Int;
  type?: AccommodationTypeWhereInput;
  city?: CityWhereInput;
  description?: TranslatableStringWhereInput;
  longDescription?: TranslatableStringWhereInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  livingArea?: Int;
  livingArea_not?: Int;
  livingArea_in?: Int[] | Int;
  livingArea_not_in?: Int[] | Int;
  livingArea_lt?: Int;
  livingArea_lte?: Int;
  livingArea_gt?: Int;
  livingArea_gte?: Int;
  outsideArea?: Int;
  outsideArea_not?: Int;
  outsideArea_in?: Int[] | Int;
  outsideArea_not_in?: Int[] | Int;
  outsideArea_lt?: Int;
  outsideArea_lte?: Int;
  outsideArea_gt?: Int;
  outsideArea_gte?: Int;
  contactPerson?: String;
  contactPerson_not?: String;
  contactPerson_in?: String[] | String;
  contactPerson_not_in?: String[] | String;
  contactPerson_lt?: String;
  contactPerson_lte?: String;
  contactPerson_gt?: String;
  contactPerson_gte?: String;
  contactPerson_contains?: String;
  contactPerson_not_contains?: String;
  contactPerson_starts_with?: String;
  contactPerson_not_starts_with?: String;
  contactPerson_ends_with?: String;
  contactPerson_not_ends_with?: String;
  contactPhone?: String;
  contactPhone_not?: String;
  contactPhone_in?: String[] | String;
  contactPhone_not_in?: String[] | String;
  contactPhone_lt?: String;
  contactPhone_lte?: String;
  contactPhone_gt?: String;
  contactPhone_gte?: String;
  contactPhone_contains?: String;
  contactPhone_not_contains?: String;
  contactPhone_starts_with?: String;
  contactPhone_not_starts_with?: String;
  contactPhone_ends_with?: String;
  contactPhone_not_ends_with?: String;
  keyAddress?: AddressWhereInput;
  address?: AddressWhereInput;
  minCapacity?: Int;
  minCapacity_not?: Int;
  minCapacity_in?: Int[] | Int;
  minCapacity_not_in?: Int[] | Int;
  minCapacity_lt?: Int;
  minCapacity_lte?: Int;
  minCapacity_gt?: Int;
  minCapacity_gte?: Int;
  maxCapacity?: Int;
  maxCapacity_not?: Int;
  maxCapacity_in?: Int[] | Int;
  maxCapacity_not_in?: Int[] | Int;
  maxCapacity_lt?: Int;
  maxCapacity_lte?: Int;
  maxCapacity_gt?: Int;
  maxCapacity_gte?: Int;
  photos_every?: PhotoWhereInput;
  photos_some?: PhotoWhereInput;
  photos_none?: PhotoWhereInput;
  owner?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  bedrooms_every?: BedroomWhereInput;
  bedrooms_some?: BedroomWhereInput;
  bedrooms_none?: BedroomWhereInput;
  bathrooms_every?: BathroomWhereInput;
  bathrooms_some?: BathroomWhereInput;
  bathrooms_none?: BathroomWhereInput;
  sites_every?: SiteWhereInput;
  sites_some?: SiteWhereInput;
  sites_none?: SiteWhereInput;
  features_every?: AccommodationFeatureWhereInput;
  features_some?: AccommodationFeatureWhereInput;
  features_none?: AccommodationFeatureWhereInput;
  AND?: AccommodationWhereInput[] | AccommodationWhereInput;
  OR?: AccommodationWhereInput[] | AccommodationWhereInput;
  NOT?: AccommodationWhereInput[] | AccommodationWhereInput;
}

export interface AccommodationTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AccommodationTypeWhereInput[] | AccommodationTypeWhereInput;
  OR?: AccommodationTypeWhereInput[] | AccommodationTypeWhereInput;
  NOT?: AccommodationTypeWhereInput[] | AccommodationTypeWhereInput;
}

export interface CityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CityWhereInput[] | CityWhereInput;
  OR?: CityWhereInput[] | CityWhereInput;
  NOT?: CityWhereInput[] | CityWhereInput;
}

export interface AddressWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  postcode?: String;
  postcode_not?: String;
  postcode_in?: String[] | String;
  postcode_not_in?: String[] | String;
  postcode_lt?: String;
  postcode_lte?: String;
  postcode_gt?: String;
  postcode_gte?: String;
  postcode_contains?: String;
  postcode_not_contains?: String;
  postcode_starts_with?: String;
  postcode_not_starts_with?: String;
  postcode_ends_with?: String;
  postcode_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  AND?: AddressWhereInput[] | AddressWhereInput;
  OR?: AddressWhereInput[] | AddressWhereInput;
  NOT?: AddressWhereInput[] | AddressWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  address?: AddressWhereInput;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  accommodations_every?: AccommodationWhereInput;
  accommodations_some?: AccommodationWhereInput;
  accommodations_none?: AccommodationWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface BedroomWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: TranslatableStringWhereInput;
  type?: BedroomTypeWhereInput;
  singleBed?: Int;
  singleBed_not?: Int;
  singleBed_in?: Int[] | Int;
  singleBed_not_in?: Int[] | Int;
  singleBed_lt?: Int;
  singleBed_lte?: Int;
  singleBed_gt?: Int;
  singleBed_gte?: Int;
  doubleBed?: Int;
  doubleBed_not?: Int;
  doubleBed_in?: Int[] | Int;
  doubleBed_not_in?: Int[] | Int;
  doubleBed_lt?: Int;
  doubleBed_lte?: Int;
  doubleBed_gt?: Int;
  doubleBed_gte?: Int;
  AND?: BedroomWhereInput[] | BedroomWhereInput;
  OR?: BedroomWhereInput[] | BedroomWhereInput;
  NOT?: BedroomWhereInput[] | BedroomWhereInput;
}

export interface BedroomTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: BedroomTypeWhereInput[] | BedroomTypeWhereInput;
  OR?: BedroomTypeWhereInput[] | BedroomTypeWhereInput;
  NOT?: BedroomTypeWhereInput[] | BedroomTypeWhereInput;
}

export interface BathroomWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: TranslatableStringWhereInput;
  type?: BathroomTypeWhereInput;
  toilet?: Int;
  toilet_not?: Int;
  toilet_in?: Int[] | Int;
  toilet_not_in?: Int[] | Int;
  toilet_lt?: Int;
  toilet_lte?: Int;
  toilet_gt?: Int;
  toilet_gte?: Int;
  bath?: Int;
  bath_not?: Int;
  bath_in?: Int[] | Int;
  bath_not_in?: Int[] | Int;
  bath_lt?: Int;
  bath_lte?: Int;
  bath_gt?: Int;
  bath_gte?: Int;
  shower?: Int;
  shower_not?: Int;
  shower_in?: Int[] | Int;
  shower_not_in?: Int[] | Int;
  shower_lt?: Int;
  shower_lte?: Int;
  shower_gt?: Int;
  shower_gte?: Int;
  AND?: BathroomWhereInput[] | BathroomWhereInput;
  OR?: BathroomWhereInput[] | BathroomWhereInput;
  NOT?: BathroomWhereInput[] | BathroomWhereInput;
}

export interface BathroomTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: BathroomTypeWhereInput[] | BathroomTypeWhereInput;
  OR?: BathroomTypeWhereInput[] | BathroomTypeWhereInput;
  NOT?: BathroomTypeWhereInput[] | BathroomTypeWhereInput;
}

export interface SiteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SiteWhereInput[] | SiteWhereInput;
  OR?: SiteWhereInput[] | SiteWhereInput;
  NOT?: SiteWhereInput[] | SiteWhereInput;
}

export interface AccommodationFeatureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AccommodationFeatureWhereInput[] | AccommodationFeatureWhereInput;
  OR?: AccommodationFeatureWhereInput[] | AccommodationFeatureWhereInput;
  NOT?: AccommodationFeatureWhereInput[] | AccommodationFeatureWhereInput;
}

export type AccommodationFeatureWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type AccommodationTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type AddressWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BathroomWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BathroomTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BedroomWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BedroomTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type CityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PhotoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SiteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TranslatableStringWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface AccommodationCreateInput {
  name: String;
  code: Int;
  type: AccommodationTypeCreateOneInput;
  city: CityCreateOneInput;
  description: TranslatableStringCreateOneInput;
  longDescription?: TranslatableStringCreateOneInput;
  slug: String;
  livingArea: Int;
  outsideArea: Int;
  contactPerson: String;
  contactPhone: String;
  keyAddress: AddressCreateOneInput;
  address: AddressCreateOneInput;
  minCapacity: Int;
  maxCapacity: Int;
  photos?: PhotoCreateManyInput;
  owner?: UserCreateOneWithoutAccommodationsInput;
  bedrooms?: BedroomCreateManyInput;
  bathrooms?: BathroomCreateManyInput;
  sites?: SiteCreateManyInput;
  features?: AccommodationFeatureCreateManyInput;
}

export interface AccommodationTypeCreateOneInput {
  create?: AccommodationTypeCreateInput;
  connect?: AccommodationTypeWhereUniqueInput;
}

export interface AccommodationTypeCreateInput {
  name?: String;
}

export interface CityCreateOneInput {
  create?: CityCreateInput;
  connect?: CityWhereUniqueInput;
}

export interface CityCreateInput {
  name?: String;
}

export interface TranslatableStringCreateOneInput {
  create?: TranslatableStringCreateInput;
  connect?: TranslatableStringWhereUniqueInput;
}

export interface TranslatableStringCreateInput {
  en?: String;
  nl?: String;
  de?: String;
}

export interface AddressCreateOneInput {
  create?: AddressCreateInput;
  connect?: AddressWhereUniqueInput;
}

export interface AddressCreateInput {
  address: String;
  postcode: String;
  city: String;
}

export interface PhotoCreateManyInput {
  create?: PhotoCreateInput[] | PhotoCreateInput;
  connect?: PhotoWhereUniqueInput[] | PhotoWhereUniqueInput;
}

export interface PhotoCreateInput {
  url: String;
  name: TranslatableStringCreateOneInput;
}

export interface UserCreateOneWithoutAccommodationsInput {
  create?: UserCreateWithoutAccommodationsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutAccommodationsInput {
  email: String;
  password?: String;
  firstName: String;
  lastName: String;
  address: AddressCreateOneInput;
  phone: String;
}

export interface BedroomCreateManyInput {
  create?: BedroomCreateInput[] | BedroomCreateInput;
  connect?: BedroomWhereUniqueInput[] | BedroomWhereUniqueInput;
}

export interface BedroomCreateInput {
  name?: TranslatableStringCreateOneInput;
  type?: BedroomTypeCreateOneInput;
  singleBed: Int;
  doubleBed: Int;
}

export interface BedroomTypeCreateOneInput {
  create?: BedroomTypeCreateInput;
  connect?: BedroomTypeWhereUniqueInput;
}

export interface BedroomTypeCreateInput {
  name?: String;
}

export interface BathroomCreateManyInput {
  create?: BathroomCreateInput[] | BathroomCreateInput;
  connect?: BathroomWhereUniqueInput[] | BathroomWhereUniqueInput;
}

export interface BathroomCreateInput {
  name?: TranslatableStringCreateOneInput;
  type?: BathroomTypeCreateOneInput;
  toilet: Int;
  bath: Int;
  shower: Int;
}

export interface BathroomTypeCreateOneInput {
  create?: BathroomTypeCreateInput;
  connect?: BathroomTypeWhereUniqueInput;
}

export interface BathroomTypeCreateInput {
  name?: String;
}

export interface SiteCreateManyInput {
  create?: SiteCreateInput[] | SiteCreateInput;
  connect?: SiteWhereUniqueInput[] | SiteWhereUniqueInput;
}

export interface SiteCreateInput {
  name: String;
}

export interface AccommodationFeatureCreateManyInput {
  create?: AccommodationFeatureCreateInput[] | AccommodationFeatureCreateInput;
  connect?:
    | AccommodationFeatureWhereUniqueInput[]
    | AccommodationFeatureWhereUniqueInput;
}

export interface AccommodationFeatureCreateInput {
  name?: String;
}

export interface AccommodationUpdateInput {
  name?: String;
  code?: Int;
  type?: AccommodationTypeUpdateOneRequiredInput;
  city?: CityUpdateOneRequiredInput;
  description?: TranslatableStringUpdateOneRequiredInput;
  longDescription?: TranslatableStringUpdateOneInput;
  slug?: String;
  livingArea?: Int;
  outsideArea?: Int;
  contactPerson?: String;
  contactPhone?: String;
  keyAddress?: AddressUpdateOneRequiredInput;
  address?: AddressUpdateOneRequiredInput;
  minCapacity?: Int;
  maxCapacity?: Int;
  photos?: PhotoUpdateManyInput;
  owner?: UserUpdateOneWithoutAccommodationsInput;
  bedrooms?: BedroomUpdateManyInput;
  bathrooms?: BathroomUpdateManyInput;
  sites?: SiteUpdateManyInput;
  features?: AccommodationFeatureUpdateManyInput;
}

export interface AccommodationTypeUpdateOneRequiredInput {
  create?: AccommodationTypeCreateInput;
  update?: AccommodationTypeUpdateDataInput;
  upsert?: AccommodationTypeUpsertNestedInput;
  connect?: AccommodationTypeWhereUniqueInput;
}

export interface AccommodationTypeUpdateDataInput {
  name?: String;
}

export interface AccommodationTypeUpsertNestedInput {
  update: AccommodationTypeUpdateDataInput;
  create: AccommodationTypeCreateInput;
}

export interface CityUpdateOneRequiredInput {
  create?: CityCreateInput;
  update?: CityUpdateDataInput;
  upsert?: CityUpsertNestedInput;
  connect?: CityWhereUniqueInput;
}

export interface CityUpdateDataInput {
  name?: String;
}

export interface CityUpsertNestedInput {
  update: CityUpdateDataInput;
  create: CityCreateInput;
}

export interface TranslatableStringUpdateOneRequiredInput {
  create?: TranslatableStringCreateInput;
  update?: TranslatableStringUpdateDataInput;
  upsert?: TranslatableStringUpsertNestedInput;
  connect?: TranslatableStringWhereUniqueInput;
}

export interface TranslatableStringUpdateDataInput {
  en?: String;
  nl?: String;
  de?: String;
}

export interface TranslatableStringUpsertNestedInput {
  update: TranslatableStringUpdateDataInput;
  create: TranslatableStringCreateInput;
}

export interface TranslatableStringUpdateOneInput {
  create?: TranslatableStringCreateInput;
  update?: TranslatableStringUpdateDataInput;
  upsert?: TranslatableStringUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TranslatableStringWhereUniqueInput;
}

export interface AddressUpdateOneRequiredInput {
  create?: AddressCreateInput;
  update?: AddressUpdateDataInput;
  upsert?: AddressUpsertNestedInput;
  connect?: AddressWhereUniqueInput;
}

export interface AddressUpdateDataInput {
  address?: String;
  postcode?: String;
  city?: String;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface PhotoUpdateManyInput {
  create?: PhotoCreateInput[] | PhotoCreateInput;
  update?:
    | PhotoUpdateWithWhereUniqueNestedInput[]
    | PhotoUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PhotoUpsertWithWhereUniqueNestedInput[]
    | PhotoUpsertWithWhereUniqueNestedInput;
  delete?: PhotoWhereUniqueInput[] | PhotoWhereUniqueInput;
  connect?: PhotoWhereUniqueInput[] | PhotoWhereUniqueInput;
  disconnect?: PhotoWhereUniqueInput[] | PhotoWhereUniqueInput;
  deleteMany?: PhotoScalarWhereInput[] | PhotoScalarWhereInput;
  updateMany?:
    | PhotoUpdateManyWithWhereNestedInput[]
    | PhotoUpdateManyWithWhereNestedInput;
}

export interface PhotoUpdateWithWhereUniqueNestedInput {
  where: PhotoWhereUniqueInput;
  data: PhotoUpdateDataInput;
}

export interface PhotoUpdateDataInput {
  url?: String;
  name?: TranslatableStringUpdateOneRequiredInput;
}

export interface PhotoUpsertWithWhereUniqueNestedInput {
  where: PhotoWhereUniqueInput;
  update: PhotoUpdateDataInput;
  create: PhotoCreateInput;
}

export interface PhotoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: PhotoScalarWhereInput[] | PhotoScalarWhereInput;
  OR?: PhotoScalarWhereInput[] | PhotoScalarWhereInput;
  NOT?: PhotoScalarWhereInput[] | PhotoScalarWhereInput;
}

export interface PhotoUpdateManyWithWhereNestedInput {
  where: PhotoScalarWhereInput;
  data: PhotoUpdateManyDataInput;
}

export interface PhotoUpdateManyDataInput {
  url?: String;
}

export interface UserUpdateOneWithoutAccommodationsInput {
  create?: UserCreateWithoutAccommodationsInput;
  update?: UserUpdateWithoutAccommodationsDataInput;
  upsert?: UserUpsertWithoutAccommodationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutAccommodationsDataInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  address?: AddressUpdateOneRequiredInput;
  phone?: String;
}

export interface UserUpsertWithoutAccommodationsInput {
  update: UserUpdateWithoutAccommodationsDataInput;
  create: UserCreateWithoutAccommodationsInput;
}

export interface BedroomUpdateManyInput {
  create?: BedroomCreateInput[] | BedroomCreateInput;
  update?:
    | BedroomUpdateWithWhereUniqueNestedInput[]
    | BedroomUpdateWithWhereUniqueNestedInput;
  upsert?:
    | BedroomUpsertWithWhereUniqueNestedInput[]
    | BedroomUpsertWithWhereUniqueNestedInput;
  delete?: BedroomWhereUniqueInput[] | BedroomWhereUniqueInput;
  connect?: BedroomWhereUniqueInput[] | BedroomWhereUniqueInput;
  disconnect?: BedroomWhereUniqueInput[] | BedroomWhereUniqueInput;
  deleteMany?: BedroomScalarWhereInput[] | BedroomScalarWhereInput;
  updateMany?:
    | BedroomUpdateManyWithWhereNestedInput[]
    | BedroomUpdateManyWithWhereNestedInput;
}

export interface BedroomUpdateWithWhereUniqueNestedInput {
  where: BedroomWhereUniqueInput;
  data: BedroomUpdateDataInput;
}

export interface BedroomUpdateDataInput {
  name?: TranslatableStringUpdateOneInput;
  type?: BedroomTypeUpdateOneInput;
  singleBed?: Int;
  doubleBed?: Int;
}

export interface BedroomTypeUpdateOneInput {
  create?: BedroomTypeCreateInput;
  update?: BedroomTypeUpdateDataInput;
  upsert?: BedroomTypeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BedroomTypeWhereUniqueInput;
}

export interface BedroomTypeUpdateDataInput {
  name?: String;
}

export interface BedroomTypeUpsertNestedInput {
  update: BedroomTypeUpdateDataInput;
  create: BedroomTypeCreateInput;
}

export interface BedroomUpsertWithWhereUniqueNestedInput {
  where: BedroomWhereUniqueInput;
  update: BedroomUpdateDataInput;
  create: BedroomCreateInput;
}

export interface BedroomScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  singleBed?: Int;
  singleBed_not?: Int;
  singleBed_in?: Int[] | Int;
  singleBed_not_in?: Int[] | Int;
  singleBed_lt?: Int;
  singleBed_lte?: Int;
  singleBed_gt?: Int;
  singleBed_gte?: Int;
  doubleBed?: Int;
  doubleBed_not?: Int;
  doubleBed_in?: Int[] | Int;
  doubleBed_not_in?: Int[] | Int;
  doubleBed_lt?: Int;
  doubleBed_lte?: Int;
  doubleBed_gt?: Int;
  doubleBed_gte?: Int;
  AND?: BedroomScalarWhereInput[] | BedroomScalarWhereInput;
  OR?: BedroomScalarWhereInput[] | BedroomScalarWhereInput;
  NOT?: BedroomScalarWhereInput[] | BedroomScalarWhereInput;
}

export interface BedroomUpdateManyWithWhereNestedInput {
  where: BedroomScalarWhereInput;
  data: BedroomUpdateManyDataInput;
}

export interface BedroomUpdateManyDataInput {
  singleBed?: Int;
  doubleBed?: Int;
}

export interface BathroomUpdateManyInput {
  create?: BathroomCreateInput[] | BathroomCreateInput;
  update?:
    | BathroomUpdateWithWhereUniqueNestedInput[]
    | BathroomUpdateWithWhereUniqueNestedInput;
  upsert?:
    | BathroomUpsertWithWhereUniqueNestedInput[]
    | BathroomUpsertWithWhereUniqueNestedInput;
  delete?: BathroomWhereUniqueInput[] | BathroomWhereUniqueInput;
  connect?: BathroomWhereUniqueInput[] | BathroomWhereUniqueInput;
  disconnect?: BathroomWhereUniqueInput[] | BathroomWhereUniqueInput;
  deleteMany?: BathroomScalarWhereInput[] | BathroomScalarWhereInput;
  updateMany?:
    | BathroomUpdateManyWithWhereNestedInput[]
    | BathroomUpdateManyWithWhereNestedInput;
}

export interface BathroomUpdateWithWhereUniqueNestedInput {
  where: BathroomWhereUniqueInput;
  data: BathroomUpdateDataInput;
}

export interface BathroomUpdateDataInput {
  name?: TranslatableStringUpdateOneInput;
  type?: BathroomTypeUpdateOneInput;
  toilet?: Int;
  bath?: Int;
  shower?: Int;
}

export interface BathroomTypeUpdateOneInput {
  create?: BathroomTypeCreateInput;
  update?: BathroomTypeUpdateDataInput;
  upsert?: BathroomTypeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BathroomTypeWhereUniqueInput;
}

export interface BathroomTypeUpdateDataInput {
  name?: String;
}

export interface BathroomTypeUpsertNestedInput {
  update: BathroomTypeUpdateDataInput;
  create: BathroomTypeCreateInput;
}

export interface BathroomUpsertWithWhereUniqueNestedInput {
  where: BathroomWhereUniqueInput;
  update: BathroomUpdateDataInput;
  create: BathroomCreateInput;
}

export interface BathroomScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  toilet?: Int;
  toilet_not?: Int;
  toilet_in?: Int[] | Int;
  toilet_not_in?: Int[] | Int;
  toilet_lt?: Int;
  toilet_lte?: Int;
  toilet_gt?: Int;
  toilet_gte?: Int;
  bath?: Int;
  bath_not?: Int;
  bath_in?: Int[] | Int;
  bath_not_in?: Int[] | Int;
  bath_lt?: Int;
  bath_lte?: Int;
  bath_gt?: Int;
  bath_gte?: Int;
  shower?: Int;
  shower_not?: Int;
  shower_in?: Int[] | Int;
  shower_not_in?: Int[] | Int;
  shower_lt?: Int;
  shower_lte?: Int;
  shower_gt?: Int;
  shower_gte?: Int;
  AND?: BathroomScalarWhereInput[] | BathroomScalarWhereInput;
  OR?: BathroomScalarWhereInput[] | BathroomScalarWhereInput;
  NOT?: BathroomScalarWhereInput[] | BathroomScalarWhereInput;
}

export interface BathroomUpdateManyWithWhereNestedInput {
  where: BathroomScalarWhereInput;
  data: BathroomUpdateManyDataInput;
}

export interface BathroomUpdateManyDataInput {
  toilet?: Int;
  bath?: Int;
  shower?: Int;
}

export interface SiteUpdateManyInput {
  create?: SiteCreateInput[] | SiteCreateInput;
  update?:
    | SiteUpdateWithWhereUniqueNestedInput[]
    | SiteUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SiteUpsertWithWhereUniqueNestedInput[]
    | SiteUpsertWithWhereUniqueNestedInput;
  delete?: SiteWhereUniqueInput[] | SiteWhereUniqueInput;
  connect?: SiteWhereUniqueInput[] | SiteWhereUniqueInput;
  disconnect?: SiteWhereUniqueInput[] | SiteWhereUniqueInput;
  deleteMany?: SiteScalarWhereInput[] | SiteScalarWhereInput;
  updateMany?:
    | SiteUpdateManyWithWhereNestedInput[]
    | SiteUpdateManyWithWhereNestedInput;
}

export interface SiteUpdateWithWhereUniqueNestedInput {
  where: SiteWhereUniqueInput;
  data: SiteUpdateDataInput;
}

export interface SiteUpdateDataInput {
  name?: String;
}

export interface SiteUpsertWithWhereUniqueNestedInput {
  where: SiteWhereUniqueInput;
  update: SiteUpdateDataInput;
  create: SiteCreateInput;
}

export interface SiteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SiteScalarWhereInput[] | SiteScalarWhereInput;
  OR?: SiteScalarWhereInput[] | SiteScalarWhereInput;
  NOT?: SiteScalarWhereInput[] | SiteScalarWhereInput;
}

export interface SiteUpdateManyWithWhereNestedInput {
  where: SiteScalarWhereInput;
  data: SiteUpdateManyDataInput;
}

export interface SiteUpdateManyDataInput {
  name?: String;
}

export interface AccommodationFeatureUpdateManyInput {
  create?: AccommodationFeatureCreateInput[] | AccommodationFeatureCreateInput;
  update?:
    | AccommodationFeatureUpdateWithWhereUniqueNestedInput[]
    | AccommodationFeatureUpdateWithWhereUniqueNestedInput;
  upsert?:
    | AccommodationFeatureUpsertWithWhereUniqueNestedInput[]
    | AccommodationFeatureUpsertWithWhereUniqueNestedInput;
  delete?:
    | AccommodationFeatureWhereUniqueInput[]
    | AccommodationFeatureWhereUniqueInput;
  connect?:
    | AccommodationFeatureWhereUniqueInput[]
    | AccommodationFeatureWhereUniqueInput;
  disconnect?:
    | AccommodationFeatureWhereUniqueInput[]
    | AccommodationFeatureWhereUniqueInput;
  deleteMany?:
    | AccommodationFeatureScalarWhereInput[]
    | AccommodationFeatureScalarWhereInput;
  updateMany?:
    | AccommodationFeatureUpdateManyWithWhereNestedInput[]
    | AccommodationFeatureUpdateManyWithWhereNestedInput;
}

export interface AccommodationFeatureUpdateWithWhereUniqueNestedInput {
  where: AccommodationFeatureWhereUniqueInput;
  data: AccommodationFeatureUpdateDataInput;
}

export interface AccommodationFeatureUpdateDataInput {
  name?: String;
}

export interface AccommodationFeatureUpsertWithWhereUniqueNestedInput {
  where: AccommodationFeatureWhereUniqueInput;
  update: AccommodationFeatureUpdateDataInput;
  create: AccommodationFeatureCreateInput;
}

export interface AccommodationFeatureScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?:
    | AccommodationFeatureScalarWhereInput[]
    | AccommodationFeatureScalarWhereInput;
  OR?:
    | AccommodationFeatureScalarWhereInput[]
    | AccommodationFeatureScalarWhereInput;
  NOT?:
    | AccommodationFeatureScalarWhereInput[]
    | AccommodationFeatureScalarWhereInput;
}

export interface AccommodationFeatureUpdateManyWithWhereNestedInput {
  where: AccommodationFeatureScalarWhereInput;
  data: AccommodationFeatureUpdateManyDataInput;
}

export interface AccommodationFeatureUpdateManyDataInput {
  name?: String;
}

export interface AccommodationUpdateManyMutationInput {
  name?: String;
  code?: Int;
  slug?: String;
  livingArea?: Int;
  outsideArea?: Int;
  contactPerson?: String;
  contactPhone?: String;
  minCapacity?: Int;
  maxCapacity?: Int;
}

export interface AccommodationFeatureUpdateInput {
  name?: String;
}

export interface AccommodationFeatureUpdateManyMutationInput {
  name?: String;
}

export interface AccommodationTypeUpdateInput {
  name?: String;
}

export interface AccommodationTypeUpdateManyMutationInput {
  name?: String;
}

export interface AddressUpdateInput {
  address?: String;
  postcode?: String;
  city?: String;
}

export interface AddressUpdateManyMutationInput {
  address?: String;
  postcode?: String;
  city?: String;
}

export interface BathroomUpdateInput {
  name?: TranslatableStringUpdateOneInput;
  type?: BathroomTypeUpdateOneInput;
  toilet?: Int;
  bath?: Int;
  shower?: Int;
}

export interface BathroomUpdateManyMutationInput {
  toilet?: Int;
  bath?: Int;
  shower?: Int;
}

export interface BathroomTypeUpdateInput {
  name?: String;
}

export interface BathroomTypeUpdateManyMutationInput {
  name?: String;
}

export interface BedroomUpdateInput {
  name?: TranslatableStringUpdateOneInput;
  type?: BedroomTypeUpdateOneInput;
  singleBed?: Int;
  doubleBed?: Int;
}

export interface BedroomUpdateManyMutationInput {
  singleBed?: Int;
  doubleBed?: Int;
}

export interface BedroomTypeUpdateInput {
  name?: String;
}

export interface BedroomTypeUpdateManyMutationInput {
  name?: String;
}

export interface CityUpdateInput {
  name?: String;
}

export interface CityUpdateManyMutationInput {
  name?: String;
}

export interface PhotoUpdateInput {
  url?: String;
  name?: TranslatableStringUpdateOneRequiredInput;
}

export interface PhotoUpdateManyMutationInput {
  url?: String;
}

export interface SiteUpdateInput {
  name?: String;
}

export interface SiteUpdateManyMutationInput {
  name?: String;
}

export interface TranslatableStringUpdateInput {
  en?: String;
  nl?: String;
  de?: String;
}

export interface TranslatableStringUpdateManyMutationInput {
  en?: String;
  nl?: String;
  de?: String;
}

export interface UserCreateInput {
  email: String;
  password?: String;
  firstName: String;
  lastName: String;
  address: AddressCreateOneInput;
  phone: String;
  accommodations?: AccommodationCreateManyWithoutOwnerInput;
}

export interface AccommodationCreateManyWithoutOwnerInput {
  create?:
    | AccommodationCreateWithoutOwnerInput[]
    | AccommodationCreateWithoutOwnerInput;
  connect?: AccommodationWhereUniqueInput[] | AccommodationWhereUniqueInput;
}

export interface AccommodationCreateWithoutOwnerInput {
  name: String;
  code: Int;
  type: AccommodationTypeCreateOneInput;
  city: CityCreateOneInput;
  description: TranslatableStringCreateOneInput;
  longDescription?: TranslatableStringCreateOneInput;
  slug: String;
  livingArea: Int;
  outsideArea: Int;
  contactPerson: String;
  contactPhone: String;
  keyAddress: AddressCreateOneInput;
  address: AddressCreateOneInput;
  minCapacity: Int;
  maxCapacity: Int;
  photos?: PhotoCreateManyInput;
  bedrooms?: BedroomCreateManyInput;
  bathrooms?: BathroomCreateManyInput;
  sites?: SiteCreateManyInput;
  features?: AccommodationFeatureCreateManyInput;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  address?: AddressUpdateOneRequiredInput;
  phone?: String;
  accommodations?: AccommodationUpdateManyWithoutOwnerInput;
}

export interface AccommodationUpdateManyWithoutOwnerInput {
  create?:
    | AccommodationCreateWithoutOwnerInput[]
    | AccommodationCreateWithoutOwnerInput;
  delete?: AccommodationWhereUniqueInput[] | AccommodationWhereUniqueInput;
  connect?: AccommodationWhereUniqueInput[] | AccommodationWhereUniqueInput;
  disconnect?: AccommodationWhereUniqueInput[] | AccommodationWhereUniqueInput;
  update?:
    | AccommodationUpdateWithWhereUniqueWithoutOwnerInput[]
    | AccommodationUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | AccommodationUpsertWithWhereUniqueWithoutOwnerInput[]
    | AccommodationUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: AccommodationScalarWhereInput[] | AccommodationScalarWhereInput;
  updateMany?:
    | AccommodationUpdateManyWithWhereNestedInput[]
    | AccommodationUpdateManyWithWhereNestedInput;
}

export interface AccommodationUpdateWithWhereUniqueWithoutOwnerInput {
  where: AccommodationWhereUniqueInput;
  data: AccommodationUpdateWithoutOwnerDataInput;
}

export interface AccommodationUpdateWithoutOwnerDataInput {
  name?: String;
  code?: Int;
  type?: AccommodationTypeUpdateOneRequiredInput;
  city?: CityUpdateOneRequiredInput;
  description?: TranslatableStringUpdateOneRequiredInput;
  longDescription?: TranslatableStringUpdateOneInput;
  slug?: String;
  livingArea?: Int;
  outsideArea?: Int;
  contactPerson?: String;
  contactPhone?: String;
  keyAddress?: AddressUpdateOneRequiredInput;
  address?: AddressUpdateOneRequiredInput;
  minCapacity?: Int;
  maxCapacity?: Int;
  photos?: PhotoUpdateManyInput;
  bedrooms?: BedroomUpdateManyInput;
  bathrooms?: BathroomUpdateManyInput;
  sites?: SiteUpdateManyInput;
  features?: AccommodationFeatureUpdateManyInput;
}

export interface AccommodationUpsertWithWhereUniqueWithoutOwnerInput {
  where: AccommodationWhereUniqueInput;
  update: AccommodationUpdateWithoutOwnerDataInput;
  create: AccommodationCreateWithoutOwnerInput;
}

export interface AccommodationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: Int;
  code_not?: Int;
  code_in?: Int[] | Int;
  code_not_in?: Int[] | Int;
  code_lt?: Int;
  code_lte?: Int;
  code_gt?: Int;
  code_gte?: Int;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  livingArea?: Int;
  livingArea_not?: Int;
  livingArea_in?: Int[] | Int;
  livingArea_not_in?: Int[] | Int;
  livingArea_lt?: Int;
  livingArea_lte?: Int;
  livingArea_gt?: Int;
  livingArea_gte?: Int;
  outsideArea?: Int;
  outsideArea_not?: Int;
  outsideArea_in?: Int[] | Int;
  outsideArea_not_in?: Int[] | Int;
  outsideArea_lt?: Int;
  outsideArea_lte?: Int;
  outsideArea_gt?: Int;
  outsideArea_gte?: Int;
  contactPerson?: String;
  contactPerson_not?: String;
  contactPerson_in?: String[] | String;
  contactPerson_not_in?: String[] | String;
  contactPerson_lt?: String;
  contactPerson_lte?: String;
  contactPerson_gt?: String;
  contactPerson_gte?: String;
  contactPerson_contains?: String;
  contactPerson_not_contains?: String;
  contactPerson_starts_with?: String;
  contactPerson_not_starts_with?: String;
  contactPerson_ends_with?: String;
  contactPerson_not_ends_with?: String;
  contactPhone?: String;
  contactPhone_not?: String;
  contactPhone_in?: String[] | String;
  contactPhone_not_in?: String[] | String;
  contactPhone_lt?: String;
  contactPhone_lte?: String;
  contactPhone_gt?: String;
  contactPhone_gte?: String;
  contactPhone_contains?: String;
  contactPhone_not_contains?: String;
  contactPhone_starts_with?: String;
  contactPhone_not_starts_with?: String;
  contactPhone_ends_with?: String;
  contactPhone_not_ends_with?: String;
  minCapacity?: Int;
  minCapacity_not?: Int;
  minCapacity_in?: Int[] | Int;
  minCapacity_not_in?: Int[] | Int;
  minCapacity_lt?: Int;
  minCapacity_lte?: Int;
  minCapacity_gt?: Int;
  minCapacity_gte?: Int;
  maxCapacity?: Int;
  maxCapacity_not?: Int;
  maxCapacity_in?: Int[] | Int;
  maxCapacity_not_in?: Int[] | Int;
  maxCapacity_lt?: Int;
  maxCapacity_lte?: Int;
  maxCapacity_gt?: Int;
  maxCapacity_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AccommodationScalarWhereInput[] | AccommodationScalarWhereInput;
  OR?: AccommodationScalarWhereInput[] | AccommodationScalarWhereInput;
  NOT?: AccommodationScalarWhereInput[] | AccommodationScalarWhereInput;
}

export interface AccommodationUpdateManyWithWhereNestedInput {
  where: AccommodationScalarWhereInput;
  data: AccommodationUpdateManyDataInput;
}

export interface AccommodationUpdateManyDataInput {
  name?: String;
  code?: Int;
  slug?: String;
  livingArea?: Int;
  outsideArea?: Int;
  contactPerson?: String;
  contactPhone?: String;
  minCapacity?: Int;
  maxCapacity?: Int;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  phone?: String;
}

export interface AccommodationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccommodationWhereInput;
  AND?:
    | AccommodationSubscriptionWhereInput[]
    | AccommodationSubscriptionWhereInput;
  OR?:
    | AccommodationSubscriptionWhereInput[]
    | AccommodationSubscriptionWhereInput;
  NOT?:
    | AccommodationSubscriptionWhereInput[]
    | AccommodationSubscriptionWhereInput;
}

export interface AccommodationFeatureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccommodationFeatureWhereInput;
  AND?:
    | AccommodationFeatureSubscriptionWhereInput[]
    | AccommodationFeatureSubscriptionWhereInput;
  OR?:
    | AccommodationFeatureSubscriptionWhereInput[]
    | AccommodationFeatureSubscriptionWhereInput;
  NOT?:
    | AccommodationFeatureSubscriptionWhereInput[]
    | AccommodationFeatureSubscriptionWhereInput;
}

export interface AccommodationTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccommodationTypeWhereInput;
  AND?:
    | AccommodationTypeSubscriptionWhereInput[]
    | AccommodationTypeSubscriptionWhereInput;
  OR?:
    | AccommodationTypeSubscriptionWhereInput[]
    | AccommodationTypeSubscriptionWhereInput;
  NOT?:
    | AccommodationTypeSubscriptionWhereInput[]
    | AccommodationTypeSubscriptionWhereInput;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AddressWhereInput;
  AND?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  OR?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  NOT?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
}

export interface BathroomSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BathroomWhereInput;
  AND?: BathroomSubscriptionWhereInput[] | BathroomSubscriptionWhereInput;
  OR?: BathroomSubscriptionWhereInput[] | BathroomSubscriptionWhereInput;
  NOT?: BathroomSubscriptionWhereInput[] | BathroomSubscriptionWhereInput;
}

export interface BathroomTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BathroomTypeWhereInput;
  AND?:
    | BathroomTypeSubscriptionWhereInput[]
    | BathroomTypeSubscriptionWhereInput;
  OR?:
    | BathroomTypeSubscriptionWhereInput[]
    | BathroomTypeSubscriptionWhereInput;
  NOT?:
    | BathroomTypeSubscriptionWhereInput[]
    | BathroomTypeSubscriptionWhereInput;
}

export interface BedroomSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BedroomWhereInput;
  AND?: BedroomSubscriptionWhereInput[] | BedroomSubscriptionWhereInput;
  OR?: BedroomSubscriptionWhereInput[] | BedroomSubscriptionWhereInput;
  NOT?: BedroomSubscriptionWhereInput[] | BedroomSubscriptionWhereInput;
}

export interface BedroomTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BedroomTypeWhereInput;
  AND?: BedroomTypeSubscriptionWhereInput[] | BedroomTypeSubscriptionWhereInput;
  OR?: BedroomTypeSubscriptionWhereInput[] | BedroomTypeSubscriptionWhereInput;
  NOT?: BedroomTypeSubscriptionWhereInput[] | BedroomTypeSubscriptionWhereInput;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CityWhereInput;
  AND?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  OR?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  NOT?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
}

export interface PhotoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PhotoWhereInput;
  AND?: PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput;
  OR?: PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput;
  NOT?: PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput;
}

export interface SiteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SiteWhereInput;
  AND?: SiteSubscriptionWhereInput[] | SiteSubscriptionWhereInput;
  OR?: SiteSubscriptionWhereInput[] | SiteSubscriptionWhereInput;
  NOT?: SiteSubscriptionWhereInput[] | SiteSubscriptionWhereInput;
}

export interface TranslatableStringSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TranslatableStringWhereInput;
  AND?:
    | TranslatableStringSubscriptionWhereInput[]
    | TranslatableStringSubscriptionWhereInput;
  OR?:
    | TranslatableStringSubscriptionWhereInput[]
    | TranslatableStringSubscriptionWhereInput;
  NOT?:
    | TranslatableStringSubscriptionWhereInput[]
    | TranslatableStringSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Accommodation {
  id: ID_Output;
  name: String;
  code: Int;
  slug: String;
  livingArea: Int;
  outsideArea: Int;
  contactPerson: String;
  contactPhone: String;
  minCapacity: Int;
  maxCapacity: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AccommodationPromise
  extends Promise<Accommodation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<Int>;
  type: <T = AccommodationTypePromise>() => T;
  city: <T = CityPromise>() => T;
  description: <T = TranslatableStringPromise>() => T;
  longDescription: <T = TranslatableStringPromise>() => T;
  slug: () => Promise<String>;
  livingArea: () => Promise<Int>;
  outsideArea: () => Promise<Int>;
  contactPerson: () => Promise<String>;
  contactPhone: () => Promise<String>;
  keyAddress: <T = AddressPromise>() => T;
  address: <T = AddressPromise>() => T;
  minCapacity: () => Promise<Int>;
  maxCapacity: () => Promise<Int>;
  photos: <T = FragmentableArray<Photo>>(
    args?: {
      where?: PhotoWhereInput;
      orderBy?: PhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bedrooms: <T = FragmentableArray<Bedroom>>(
    args?: {
      where?: BedroomWhereInput;
      orderBy?: BedroomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bathrooms: <T = FragmentableArray<Bathroom>>(
    args?: {
      where?: BathroomWhereInput;
      orderBy?: BathroomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sites: <T = FragmentableArray<Site>>(
    args?: {
      where?: SiteWhereInput;
      orderBy?: SiteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  features: <T = FragmentableArray<AccommodationFeature>>(
    args?: {
      where?: AccommodationFeatureWhereInput;
      orderBy?: AccommodationFeatureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AccommodationSubscription
  extends Promise<AsyncIterator<Accommodation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<Int>>;
  type: <T = AccommodationTypeSubscription>() => T;
  city: <T = CitySubscription>() => T;
  description: <T = TranslatableStringSubscription>() => T;
  longDescription: <T = TranslatableStringSubscription>() => T;
  slug: () => Promise<AsyncIterator<String>>;
  livingArea: () => Promise<AsyncIterator<Int>>;
  outsideArea: () => Promise<AsyncIterator<Int>>;
  contactPerson: () => Promise<AsyncIterator<String>>;
  contactPhone: () => Promise<AsyncIterator<String>>;
  keyAddress: <T = AddressSubscription>() => T;
  address: <T = AddressSubscription>() => T;
  minCapacity: () => Promise<AsyncIterator<Int>>;
  maxCapacity: () => Promise<AsyncIterator<Int>>;
  photos: <T = Promise<AsyncIterator<PhotoSubscription>>>(
    args?: {
      where?: PhotoWhereInput;
      orderBy?: PhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bedrooms: <T = Promise<AsyncIterator<BedroomSubscription>>>(
    args?: {
      where?: BedroomWhereInput;
      orderBy?: BedroomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bathrooms: <T = Promise<AsyncIterator<BathroomSubscription>>>(
    args?: {
      where?: BathroomWhereInput;
      orderBy?: BathroomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sites: <T = Promise<AsyncIterator<SiteSubscription>>>(
    args?: {
      where?: SiteWhereInput;
      orderBy?: SiteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  features: <T = Promise<AsyncIterator<AccommodationFeatureSubscription>>>(
    args?: {
      where?: AccommodationFeatureWhereInput;
      orderBy?: AccommodationFeatureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AccommodationType {
  id: ID_Output;
  name?: String;
}

export interface AccommodationTypePromise
  extends Promise<AccommodationType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AccommodationTypeSubscription
  extends Promise<AsyncIterator<AccommodationType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface City {
  id: ID_Output;
  name?: String;
}

export interface CityPromise extends Promise<City>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CitySubscription
  extends Promise<AsyncIterator<City>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TranslatableString {
  id: ID_Output;
  en?: String;
  nl?: String;
  de?: String;
}

export interface TranslatableStringPromise
  extends Promise<TranslatableString>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  en: () => Promise<String>;
  nl: () => Promise<String>;
  de: () => Promise<String>;
}

export interface TranslatableStringSubscription
  extends Promise<AsyncIterator<TranslatableString>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  en: () => Promise<AsyncIterator<String>>;
  nl: () => Promise<AsyncIterator<String>>;
  de: () => Promise<AsyncIterator<String>>;
}

export interface Address {
  id: ID_Output;
  address: String;
  postcode: String;
  city: String;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  postcode: () => Promise<String>;
  city: () => Promise<String>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: () => Promise<AsyncIterator<String>>;
  postcode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
}

export interface Photo {
  id: ID_Output;
  url: String;
}

export interface PhotoPromise extends Promise<Photo>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  name: <T = TranslatableStringPromise>() => T;
}

export interface PhotoSubscription
  extends Promise<AsyncIterator<Photo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  name: <T = TranslatableStringSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  password?: String;
  firstName: String;
  lastName: String;
  phone: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  address: <T = AddressPromise>() => T;
  phone: () => Promise<String>;
  accommodations: <T = FragmentableArray<Accommodation>>(
    args?: {
      where?: AccommodationWhereInput;
      orderBy?: AccommodationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  address: <T = AddressSubscription>() => T;
  phone: () => Promise<AsyncIterator<String>>;
  accommodations: <T = Promise<AsyncIterator<AccommodationSubscription>>>(
    args?: {
      where?: AccommodationWhereInput;
      orderBy?: AccommodationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Bedroom {
  id: ID_Output;
  singleBed: Int;
  doubleBed: Int;
}

export interface BedroomPromise extends Promise<Bedroom>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: <T = TranslatableStringPromise>() => T;
  type: <T = BedroomTypePromise>() => T;
  singleBed: () => Promise<Int>;
  doubleBed: () => Promise<Int>;
}

export interface BedroomSubscription
  extends Promise<AsyncIterator<Bedroom>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: <T = TranslatableStringSubscription>() => T;
  type: <T = BedroomTypeSubscription>() => T;
  singleBed: () => Promise<AsyncIterator<Int>>;
  doubleBed: () => Promise<AsyncIterator<Int>>;
}

export interface BedroomType {
  id: ID_Output;
  name?: String;
}

export interface BedroomTypePromise extends Promise<BedroomType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BedroomTypeSubscription
  extends Promise<AsyncIterator<BedroomType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Bathroom {
  id: ID_Output;
  toilet: Int;
  bath: Int;
  shower: Int;
}

export interface BathroomPromise extends Promise<Bathroom>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: <T = TranslatableStringPromise>() => T;
  type: <T = BathroomTypePromise>() => T;
  toilet: () => Promise<Int>;
  bath: () => Promise<Int>;
  shower: () => Promise<Int>;
}

export interface BathroomSubscription
  extends Promise<AsyncIterator<Bathroom>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: <T = TranslatableStringSubscription>() => T;
  type: <T = BathroomTypeSubscription>() => T;
  toilet: () => Promise<AsyncIterator<Int>>;
  bath: () => Promise<AsyncIterator<Int>>;
  shower: () => Promise<AsyncIterator<Int>>;
}

export interface BathroomType {
  id: ID_Output;
  name?: String;
}

export interface BathroomTypePromise
  extends Promise<BathroomType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BathroomTypeSubscription
  extends Promise<AsyncIterator<BathroomType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Site {
  id: ID_Output;
  name: String;
}

export interface SitePromise extends Promise<Site>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SiteSubscription
  extends Promise<AsyncIterator<Site>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AccommodationFeature {
  id: ID_Output;
  name?: String;
}

export interface AccommodationFeaturePromise
  extends Promise<AccommodationFeature>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AccommodationFeatureSubscription
  extends Promise<AsyncIterator<AccommodationFeature>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AccommodationConnection {}

export interface AccommodationConnectionPromise
  extends Promise<AccommodationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccommodationEdge>>() => T;
  aggregate: <T = AggregateAccommodationPromise>() => T;
}

export interface AccommodationConnectionSubscription
  extends Promise<AsyncIterator<AccommodationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccommodationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccommodationSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AccommodationEdge {
  cursor: String;
}

export interface AccommodationEdgePromise
  extends Promise<AccommodationEdge>,
    Fragmentable {
  node: <T = AccommodationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccommodationEdgeSubscription
  extends Promise<AsyncIterator<AccommodationEdge>>,
    Fragmentable {
  node: <T = AccommodationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccommodation {
  count: Int;
}

export interface AggregateAccommodationPromise
  extends Promise<AggregateAccommodation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccommodationSubscription
  extends Promise<AsyncIterator<AggregateAccommodation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccommodationFeatureConnection {}

export interface AccommodationFeatureConnectionPromise
  extends Promise<AccommodationFeatureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccommodationFeatureEdge>>() => T;
  aggregate: <T = AggregateAccommodationFeaturePromise>() => T;
}

export interface AccommodationFeatureConnectionSubscription
  extends Promise<AsyncIterator<AccommodationFeatureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<AccommodationFeatureEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateAccommodationFeatureSubscription>() => T;
}

export interface AccommodationFeatureEdge {
  cursor: String;
}

export interface AccommodationFeatureEdgePromise
  extends Promise<AccommodationFeatureEdge>,
    Fragmentable {
  node: <T = AccommodationFeaturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccommodationFeatureEdgeSubscription
  extends Promise<AsyncIterator<AccommodationFeatureEdge>>,
    Fragmentable {
  node: <T = AccommodationFeatureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccommodationFeature {
  count: Int;
}

export interface AggregateAccommodationFeaturePromise
  extends Promise<AggregateAccommodationFeature>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccommodationFeatureSubscription
  extends Promise<AsyncIterator<AggregateAccommodationFeature>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccommodationTypeConnection {}

export interface AccommodationTypeConnectionPromise
  extends Promise<AccommodationTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccommodationTypeEdge>>() => T;
  aggregate: <T = AggregateAccommodationTypePromise>() => T;
}

export interface AccommodationTypeConnectionSubscription
  extends Promise<AsyncIterator<AccommodationTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccommodationTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccommodationTypeSubscription>() => T;
}

export interface AccommodationTypeEdge {
  cursor: String;
}

export interface AccommodationTypeEdgePromise
  extends Promise<AccommodationTypeEdge>,
    Fragmentable {
  node: <T = AccommodationTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccommodationTypeEdgeSubscription
  extends Promise<AsyncIterator<AccommodationTypeEdge>>,
    Fragmentable {
  node: <T = AccommodationTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccommodationType {
  count: Int;
}

export interface AggregateAccommodationTypePromise
  extends Promise<AggregateAccommodationType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccommodationTypeSubscription
  extends Promise<AsyncIterator<AggregateAccommodationType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressConnection {}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface AddressEdge {
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BathroomConnection {}

export interface BathroomConnectionPromise
  extends Promise<BathroomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BathroomEdge>>() => T;
  aggregate: <T = AggregateBathroomPromise>() => T;
}

export interface BathroomConnectionSubscription
  extends Promise<AsyncIterator<BathroomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BathroomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBathroomSubscription>() => T;
}

export interface BathroomEdge {
  cursor: String;
}

export interface BathroomEdgePromise
  extends Promise<BathroomEdge>,
    Fragmentable {
  node: <T = BathroomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BathroomEdgeSubscription
  extends Promise<AsyncIterator<BathroomEdge>>,
    Fragmentable {
  node: <T = BathroomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBathroom {
  count: Int;
}

export interface AggregateBathroomPromise
  extends Promise<AggregateBathroom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBathroomSubscription
  extends Promise<AsyncIterator<AggregateBathroom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BathroomTypeConnection {}

export interface BathroomTypeConnectionPromise
  extends Promise<BathroomTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BathroomTypeEdge>>() => T;
  aggregate: <T = AggregateBathroomTypePromise>() => T;
}

export interface BathroomTypeConnectionSubscription
  extends Promise<AsyncIterator<BathroomTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BathroomTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBathroomTypeSubscription>() => T;
}

export interface BathroomTypeEdge {
  cursor: String;
}

export interface BathroomTypeEdgePromise
  extends Promise<BathroomTypeEdge>,
    Fragmentable {
  node: <T = BathroomTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BathroomTypeEdgeSubscription
  extends Promise<AsyncIterator<BathroomTypeEdge>>,
    Fragmentable {
  node: <T = BathroomTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBathroomType {
  count: Int;
}

export interface AggregateBathroomTypePromise
  extends Promise<AggregateBathroomType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBathroomTypeSubscription
  extends Promise<AsyncIterator<AggregateBathroomType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BedroomConnection {}

export interface BedroomConnectionPromise
  extends Promise<BedroomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BedroomEdge>>() => T;
  aggregate: <T = AggregateBedroomPromise>() => T;
}

export interface BedroomConnectionSubscription
  extends Promise<AsyncIterator<BedroomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BedroomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBedroomSubscription>() => T;
}

export interface BedroomEdge {
  cursor: String;
}

export interface BedroomEdgePromise extends Promise<BedroomEdge>, Fragmentable {
  node: <T = BedroomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BedroomEdgeSubscription
  extends Promise<AsyncIterator<BedroomEdge>>,
    Fragmentable {
  node: <T = BedroomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBedroom {
  count: Int;
}

export interface AggregateBedroomPromise
  extends Promise<AggregateBedroom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBedroomSubscription
  extends Promise<AsyncIterator<AggregateBedroom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BedroomTypeConnection {}

export interface BedroomTypeConnectionPromise
  extends Promise<BedroomTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BedroomTypeEdge>>() => T;
  aggregate: <T = AggregateBedroomTypePromise>() => T;
}

export interface BedroomTypeConnectionSubscription
  extends Promise<AsyncIterator<BedroomTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BedroomTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBedroomTypeSubscription>() => T;
}

export interface BedroomTypeEdge {
  cursor: String;
}

export interface BedroomTypeEdgePromise
  extends Promise<BedroomTypeEdge>,
    Fragmentable {
  node: <T = BedroomTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BedroomTypeEdgeSubscription
  extends Promise<AsyncIterator<BedroomTypeEdge>>,
    Fragmentable {
  node: <T = BedroomTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBedroomType {
  count: Int;
}

export interface AggregateBedroomTypePromise
  extends Promise<AggregateBedroomType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBedroomTypeSubscription
  extends Promise<AsyncIterator<AggregateBedroomType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CityConnection {}

export interface CityConnectionPromise
  extends Promise<CityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CityEdge>>() => T;
  aggregate: <T = AggregateCityPromise>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface CityEdge {
  cursor: String;
}

export interface CityEdgePromise extends Promise<CityEdge>, Fragmentable {
  node: <T = CityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdge>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCity {
  count: Int;
}

export interface AggregateCityPromise
  extends Promise<AggregateCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhotoConnection {}

export interface PhotoConnectionPromise
  extends Promise<PhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhotoEdge>>() => T;
  aggregate: <T = AggregatePhotoPromise>() => T;
}

export interface PhotoConnectionSubscription
  extends Promise<AsyncIterator<PhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhotoSubscription>() => T;
}

export interface PhotoEdge {
  cursor: String;
}

export interface PhotoEdgePromise extends Promise<PhotoEdge>, Fragmentable {
  node: <T = PhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhotoEdgeSubscription
  extends Promise<AsyncIterator<PhotoEdge>>,
    Fragmentable {
  node: <T = PhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhoto {
  count: Int;
}

export interface AggregatePhotoPromise
  extends Promise<AggregatePhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhotoSubscription
  extends Promise<AsyncIterator<AggregatePhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SiteConnection {}

export interface SiteConnectionPromise
  extends Promise<SiteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SiteEdge>>() => T;
  aggregate: <T = AggregateSitePromise>() => T;
}

export interface SiteConnectionSubscription
  extends Promise<AsyncIterator<SiteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SiteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSiteSubscription>() => T;
}

export interface SiteEdge {
  cursor: String;
}

export interface SiteEdgePromise extends Promise<SiteEdge>, Fragmentable {
  node: <T = SitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SiteEdgeSubscription
  extends Promise<AsyncIterator<SiteEdge>>,
    Fragmentable {
  node: <T = SiteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSite {
  count: Int;
}

export interface AggregateSitePromise
  extends Promise<AggregateSite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSiteSubscription
  extends Promise<AsyncIterator<AggregateSite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TranslatableStringConnection {}

export interface TranslatableStringConnectionPromise
  extends Promise<TranslatableStringConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TranslatableStringEdge>>() => T;
  aggregate: <T = AggregateTranslatableStringPromise>() => T;
}

export interface TranslatableStringConnectionSubscription
  extends Promise<AsyncIterator<TranslatableStringConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TranslatableStringEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTranslatableStringSubscription>() => T;
}

export interface TranslatableStringEdge {
  cursor: String;
}

export interface TranslatableStringEdgePromise
  extends Promise<TranslatableStringEdge>,
    Fragmentable {
  node: <T = TranslatableStringPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TranslatableStringEdgeSubscription
  extends Promise<AsyncIterator<TranslatableStringEdge>>,
    Fragmentable {
  node: <T = TranslatableStringSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTranslatableString {
  count: Int;
}

export interface AggregateTranslatableStringPromise
  extends Promise<AggregateTranslatableString>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTranslatableStringSubscription
  extends Promise<AsyncIterator<AggregateTranslatableString>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccommodationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AccommodationSubscriptionPayloadPromise
  extends Promise<AccommodationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccommodationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccommodationPreviousValuesPromise>() => T;
}

export interface AccommodationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccommodationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccommodationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccommodationPreviousValuesSubscription>() => T;
}

export interface AccommodationPreviousValues {
  id: ID_Output;
  name: String;
  code: Int;
  slug: String;
  livingArea: Int;
  outsideArea: Int;
  contactPerson: String;
  contactPhone: String;
  minCapacity: Int;
  maxCapacity: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AccommodationPreviousValuesPromise
  extends Promise<AccommodationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<Int>;
  slug: () => Promise<String>;
  livingArea: () => Promise<Int>;
  outsideArea: () => Promise<Int>;
  contactPerson: () => Promise<String>;
  contactPhone: () => Promise<String>;
  minCapacity: () => Promise<Int>;
  maxCapacity: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccommodationPreviousValuesSubscription
  extends Promise<AsyncIterator<AccommodationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<Int>>;
  slug: () => Promise<AsyncIterator<String>>;
  livingArea: () => Promise<AsyncIterator<Int>>;
  outsideArea: () => Promise<AsyncIterator<Int>>;
  contactPerson: () => Promise<AsyncIterator<String>>;
  contactPhone: () => Promise<AsyncIterator<String>>;
  minCapacity: () => Promise<AsyncIterator<Int>>;
  maxCapacity: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AccommodationFeatureSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AccommodationFeatureSubscriptionPayloadPromise
  extends Promise<AccommodationFeatureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccommodationFeaturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccommodationFeaturePreviousValuesPromise>() => T;
}

export interface AccommodationFeatureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccommodationFeatureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccommodationFeatureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccommodationFeaturePreviousValuesSubscription>() => T;
}

export interface AccommodationFeaturePreviousValues {
  id: ID_Output;
  name?: String;
}

export interface AccommodationFeaturePreviousValuesPromise
  extends Promise<AccommodationFeaturePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AccommodationFeaturePreviousValuesSubscription
  extends Promise<AsyncIterator<AccommodationFeaturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AccommodationTypeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AccommodationTypeSubscriptionPayloadPromise
  extends Promise<AccommodationTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccommodationTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccommodationTypePreviousValuesPromise>() => T;
}

export interface AccommodationTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccommodationTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccommodationTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccommodationTypePreviousValuesSubscription>() => T;
}

export interface AccommodationTypePreviousValues {
  id: ID_Output;
  name?: String;
}

export interface AccommodationTypePreviousValuesPromise
  extends Promise<AccommodationTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AccommodationTypePreviousValuesSubscription
  extends Promise<AsyncIterator<AccommodationTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AddressPreviousValues {
  id: ID_Output;
  address: String;
  postcode: String;
  city: String;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  postcode: () => Promise<String>;
  city: () => Promise<String>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: () => Promise<AsyncIterator<String>>;
  postcode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
}

export interface BathroomSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BathroomSubscriptionPayloadPromise
  extends Promise<BathroomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BathroomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BathroomPreviousValuesPromise>() => T;
}

export interface BathroomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BathroomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BathroomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BathroomPreviousValuesSubscription>() => T;
}

export interface BathroomPreviousValues {
  id: ID_Output;
  toilet: Int;
  bath: Int;
  shower: Int;
}

export interface BathroomPreviousValuesPromise
  extends Promise<BathroomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  toilet: () => Promise<Int>;
  bath: () => Promise<Int>;
  shower: () => Promise<Int>;
}

export interface BathroomPreviousValuesSubscription
  extends Promise<AsyncIterator<BathroomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  toilet: () => Promise<AsyncIterator<Int>>;
  bath: () => Promise<AsyncIterator<Int>>;
  shower: () => Promise<AsyncIterator<Int>>;
}

export interface BathroomTypeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BathroomTypeSubscriptionPayloadPromise
  extends Promise<BathroomTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BathroomTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BathroomTypePreviousValuesPromise>() => T;
}

export interface BathroomTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BathroomTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BathroomTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BathroomTypePreviousValuesSubscription>() => T;
}

export interface BathroomTypePreviousValues {
  id: ID_Output;
  name?: String;
}

export interface BathroomTypePreviousValuesPromise
  extends Promise<BathroomTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BathroomTypePreviousValuesSubscription
  extends Promise<AsyncIterator<BathroomTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface BedroomSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BedroomSubscriptionPayloadPromise
  extends Promise<BedroomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BedroomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BedroomPreviousValuesPromise>() => T;
}

export interface BedroomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BedroomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BedroomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BedroomPreviousValuesSubscription>() => T;
}

export interface BedroomPreviousValues {
  id: ID_Output;
  singleBed: Int;
  doubleBed: Int;
}

export interface BedroomPreviousValuesPromise
  extends Promise<BedroomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  singleBed: () => Promise<Int>;
  doubleBed: () => Promise<Int>;
}

export interface BedroomPreviousValuesSubscription
  extends Promise<AsyncIterator<BedroomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  singleBed: () => Promise<AsyncIterator<Int>>;
  doubleBed: () => Promise<AsyncIterator<Int>>;
}

export interface BedroomTypeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BedroomTypeSubscriptionPayloadPromise
  extends Promise<BedroomTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BedroomTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BedroomTypePreviousValuesPromise>() => T;
}

export interface BedroomTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BedroomTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BedroomTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BedroomTypePreviousValuesSubscription>() => T;
}

export interface BedroomTypePreviousValues {
  id: ID_Output;
  name?: String;
}

export interface BedroomTypePreviousValuesPromise
  extends Promise<BedroomTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BedroomTypePreviousValuesSubscription
  extends Promise<AsyncIterator<BedroomTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CitySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CitySubscriptionPayloadPromise
  extends Promise<CitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValuesPromise>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface CityPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface CityPreviousValuesPromise
  extends Promise<CityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PhotoSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PhotoSubscriptionPayloadPromise
  extends Promise<PhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhotoPreviousValuesPromise>() => T;
}

export interface PhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhotoPreviousValuesSubscription>() => T;
}

export interface PhotoPreviousValues {
  id: ID_Output;
  url: String;
}

export interface PhotoPreviousValuesPromise
  extends Promise<PhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<PhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface SiteSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SiteSubscriptionPayloadPromise
  extends Promise<SiteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SitePreviousValuesPromise>() => T;
}

export interface SiteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SiteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SiteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SitePreviousValuesSubscription>() => T;
}

export interface SitePreviousValues {
  id: ID_Output;
  name: String;
}

export interface SitePreviousValuesPromise
  extends Promise<SitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SitePreviousValuesSubscription
  extends Promise<AsyncIterator<SitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TranslatableStringSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TranslatableStringSubscriptionPayloadPromise
  extends Promise<TranslatableStringSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TranslatableStringPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TranslatableStringPreviousValuesPromise>() => T;
}

export interface TranslatableStringSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TranslatableStringSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TranslatableStringSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TranslatableStringPreviousValuesSubscription>() => T;
}

export interface TranslatableStringPreviousValues {
  id: ID_Output;
  en?: String;
  nl?: String;
  de?: String;
}

export interface TranslatableStringPreviousValuesPromise
  extends Promise<TranslatableStringPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  en: () => Promise<String>;
  nl: () => Promise<String>;
  de: () => Promise<String>;
}

export interface TranslatableStringPreviousValuesSubscription
  extends Promise<AsyncIterator<TranslatableStringPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  en: () => Promise<AsyncIterator<String>>;
  nl: () => Promise<AsyncIterator<String>>;
  de: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password?: String;
  firstName: String;
  lastName: String;
  phone: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Accommodation",
    embedded: false
  },
  {
    name: "AccommodationFeature",
    embedded: false
  },
  {
    name: "AccommodationType",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Bathroom",
    embedded: false
  },
  {
    name: "BathroomType",
    embedded: false
  },
  {
    name: "Bedroom",
    embedded: false
  },
  {
    name: "BedroomType",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "Photo",
    embedded: false
  },
  {
    name: "Site",
    embedded: false
  },
  {
    name: "TranslatableString",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
